/* eslint-disable class-methods-use-this */
/* eslint-disable max-classes-per-file */
import React from 'react';
import ReactDOM from 'react-dom';
import clonedeep from 'lodash.clonedeep';
import createProxyRoot from './helpers/proxyRoot';
import { EventProvider } from './components/EventContext';
import registeredPlugins from './plugins/plugins';
import getSerialized from './helpers/getSerialized';
class WebComponentFactory {
    constructor(componentProperties, rootComponent, shadow, anonymousSlot, plugins, connectCallback) {
        this.componentProperties = componentProperties;
        this.rootComponent = rootComponent;
        this.shadow = shadow;
        this.anonymousSlot = anonymousSlot;
        this.plugins = plugins;
        this.connectCallback = connectCallback;
        this.componentAttributes = {};
        this.reflectPropertiesToAttributes();
    }
    /**
     * All properties with primitive values are added to attributes.
     */
    reflectPropertiesToAttributes() {
        Object.entries(this.componentProperties).forEach(([key, value]) => {
            if (typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'boolean') {
                return;
            }
            this.componentAttributes[key.toLowerCase()] = {
                property: key,
                value,
            };
        });
    }
    /**
     * Create new class that will serve as the Web Component.
     */
    create() {
        const factory = this;
        return class WebComponent extends HTMLElement {
            constructor() {
                super();
                this.initialProperties = clonedeep(factory.componentProperties);
                this.properties = {};
                this.hasConnected = false;
                /**
                 * Dispatch an event from the Web Component
                 */
                this.eventDispatcher = (event) => {
                    this.dispatchEvent(event);
                };
                this.transferInitialProperties();
                this.subscribeToProperties();
            }
            /**
             * Observe attributes for changes.
             * Part of the Web Component Standard.
             */
            static get observedAttributes() {
                return Object.keys(factory.componentAttributes);
            }
            /**
             * Web Component gets mounted on the DOM.
             */
            connectedCallback() {
                var _a;
                this.mountReactApp({ initial: true });
                this.hasConnected = true;
                (_a = factory.connectCallback) === null || _a === void 0 ? void 0 : _a.call(factory, this);
            }
            /**
             * When an attribute is changed, this callback function is called.
             * @param name name of the attribute
             * @param oldValue value before change
             * @param newValue value after change
             */
            attributeChangedCallback(name, oldValue, newValue) {
                if (!this.hasConnected) {
                    return;
                }
                if (oldValue === newValue) {
                    return;
                }
                if (!factory.componentAttributes.hasOwnProperty(name)) {
                    return;
                }
                const propertyName = factory.componentAttributes[name].property;
                this.properties[propertyName] = getSerialized(newValue);
                this.mountReactApp();
            }
            /**
             * When a property is changed, this callback function is called.
             * @param name name of the property
             * @param oldValue value before change
             * @param newValue value after change
             */
            propertyChangedCallback(name, oldValue, newValue) {
                if (!this.hasConnected) {
                    return;
                }
                if (oldValue === newValue) {
                    return;
                }
                this.properties[name] = newValue;
                this.mountReactApp();
            }
            /**
             * Web Component gets unmounted from the DOM.
             */
            disconnectedCallback() {
                ReactDOM.unmountComponentAtNode(this);
            }
            /**
             * Setup getters and setters for all properties.
             * Here we ensure that the 'propertyChangedCallback' will get invoked
             * when a property changes.
             */
            subscribeToProperties() {
                const propertyMap = {};
                Object.keys(this.initialProperties).forEach((key) => {
                    propertyMap[key] = {
                        configurable: true,
                        enumerable: true,
                        get: () => {
                            const currentValue = this.properties.hasOwnProperty(key)
                                ? this.properties[key]
                                : this.initialProperties[key];
                            return currentValue;
                        },
                        set: (newValue) => {
                            const oldValue = this.properties.hasOwnProperty(key)
                                ? this.properties[key]
                                : this.initialProperties[key];
                            this.propertyChangedCallback(key, oldValue, newValue);
                        },
                    };
                });
                Object.defineProperties(this, propertyMap);
            }
            /**
             * Syncronize all properties and attributes
             */
            syncronizePropertiesAndAttributes() {
                Object.keys(this.initialProperties).forEach((key) => {
                    if (this.properties.hasOwnProperty(key)) {
                        return;
                    }
                    if (this.getAttribute(key) !== null) {
                        this.properties[key] = getSerialized(this.getAttribute(key));
                        return;
                    }
                    this.properties[key] = this.initialProperties[key];
                });
            }
            /**
             * Transfer initial properties from the custom element.
             */
            transferInitialProperties() {
                Object.keys(this.initialProperties).forEach((key) => {
                    if (this.hasOwnProperty(key)) {
                        this.properties[key] = this[key];
                    }
                });
            }
            /**
             * Apply plugins
             */
            applyPlugins(application) {
                const shadowChildren = [];
                const applicationWithPlugins = registeredPlugins.reduce((app, currentPlugin) => {
                    const pluginResult = currentPlugin(this, factory.plugins, app);
                    if (!pluginResult) {
                        return app;
                    }
                    const [wrapper, shadowChild] = pluginResult;
                    if (shadowChild) {
                        shadowChildren.push(shadowChild);
                    }
                    return wrapper;
                }, application);
                return [applicationWithPlugins, shadowChildren];
            }
            /**
             * Generate react props based on properties and attributes.
             */
            reactProps() {
                this.syncronizePropertiesAndAttributes();
                return this.properties;
            }
            /**
             * Mount React App onto the Web Component
             */
            mountReactApp(options) {
                const anonymousSlot = factory.anonymousSlot ? React.createElement('slot') : undefined;
                const application = (React.createElement(EventProvider, { value: this.eventDispatcher }, React.createElement(factory.rootComponent, this.reactProps(), anonymousSlot)));
                const [applicationWithPlugins, shadowChildren] = this.applyPlugins(application);
                if (!factory.shadow) {
                    ReactDOM.render(applicationWithPlugins, this);
                    return;
                }
                let currentChildren;
                if (options === null || options === void 0 ? void 0 : options.initial) {
                    currentChildren = Array.from(this.children).map((child) => child.cloneNode(true));
                }
                const root = createProxyRoot(this, shadowChildren);
                ReactDOM.render(React.createElement(root.open, null, applicationWithPlugins), this);
                if (currentChildren) {
                    currentChildren.forEach((child) => this.append(child));
                }
            }
        };
    }
}
export default WebComponentFactory;
